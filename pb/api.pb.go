// Code generated by protoc-gen-go.
// source: api.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	api.proto
	configuration.proto
	storage.proto

It has these top-level messages:
	AccountRef
	LogRef
	MapRef
	LogTreeHashRequest
	LogTreeHashResponse
	MapTreeHashRequest
	MapTreeHashResponse
	LogInclusionProofRequest
	LogInclusionProofResponse
	LogConsistencyProofRequest
	LogConsistencyProofResponse
	LeafData
	LogAddEntryRequest
	LogAddEntryResponse
	MapSetValueRequest
	MapSetValueResponse
	MapGetValueRequest
	MapGetValueResponse
	LogFetchEntriesRequest
	LogFetchEntriesResponse
	MapMutation
	ServerConfig
	AccessPolicy
	ResourceAccount
	Mutation
	LeafNode
	TreeNode
	LogTreeHash
	EntryIndex
	ObjectSize
	MapNode
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type LogType int32

const (
	LogType_STRUCT_TYPE_LOG          LogType = 0
	LogType_STRUCT_TYPE_MUTATION_LOG LogType = 1
	LogType_STRUCT_TYPE_TREEHEAD_LOG LogType = 2
)

var LogType_name = map[int32]string{
	0: "STRUCT_TYPE_LOG",
	1: "STRUCT_TYPE_MUTATION_LOG",
	2: "STRUCT_TYPE_TREEHEAD_LOG",
}
var LogType_value = map[string]int32{
	"STRUCT_TYPE_LOG":          0,
	"STRUCT_TYPE_MUTATION_LOG": 1,
	"STRUCT_TYPE_TREEHEAD_LOG": 2,
}

func (x LogType) String() string {
	return proto.EnumName(LogType_name, int32(x))
}
func (LogType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type DataFormat int32

const (
	DataFormat_UNSPECIFIED DataFormat = 0
	DataFormat_JSON        DataFormat = 1
)

var DataFormat_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "JSON",
}
var DataFormat_value = map[string]int32{
	"UNSPECIFIED": 0,
	"JSON":        1,
}

func (x DataFormat) String() string {
	return proto.EnumName(DataFormat_name, int32(x))
}
func (DataFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type AccountRef struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	ApiKey string `protobuf:"bytes,2,opt,name=api_key,json=apiKey" json:"api_key,omitempty"`
}

func (m *AccountRef) Reset()                    { *m = AccountRef{} }
func (m *AccountRef) String() string            { return proto.CompactTextString(m) }
func (*AccountRef) ProtoMessage()               {}
func (*AccountRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AccountRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AccountRef) GetApiKey() string {
	if m != nil {
		return m.ApiKey
	}
	return ""
}

type LogRef struct {
	Account *AccountRef `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	LogType LogType     `protobuf:"varint,2,opt,name=log_type,json=logType,enum=com.continusec.verifiabledatastructures.api.LogType" json:"log_type,omitempty"`
	Name    string      `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *LogRef) Reset()                    { *m = LogRef{} }
func (m *LogRef) String() string            { return proto.CompactTextString(m) }
func (*LogRef) ProtoMessage()               {}
func (*LogRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *LogRef) GetAccount() *AccountRef {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *LogRef) GetLogType() LogType {
	if m != nil {
		return m.LogType
	}
	return LogType_STRUCT_TYPE_LOG
}

func (m *LogRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type MapRef struct {
	Account *AccountRef `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Name    string      `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *MapRef) Reset()                    { *m = MapRef{} }
func (m *MapRef) String() string            { return proto.CompactTextString(m) }
func (*MapRef) ProtoMessage()               {}
func (*MapRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *MapRef) GetAccount() *AccountRef {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *MapRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type LogTreeHashRequest struct {
	Log      *LogRef `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
	TreeSize int64   `protobuf:"varint,2,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
}

func (m *LogTreeHashRequest) Reset()                    { *m = LogTreeHashRequest{} }
func (m *LogTreeHashRequest) String() string            { return proto.CompactTextString(m) }
func (*LogTreeHashRequest) ProtoMessage()               {}
func (*LogTreeHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *LogTreeHashRequest) GetLog() *LogRef {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogTreeHashRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

type LogTreeHashResponse struct {
	TreeSize int64  `protobuf:"varint,1,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	RootHash []byte `protobuf:"bytes,2,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
}

func (m *LogTreeHashResponse) Reset()                    { *m = LogTreeHashResponse{} }
func (m *LogTreeHashResponse) String() string            { return proto.CompactTextString(m) }
func (*LogTreeHashResponse) ProtoMessage()               {}
func (*LogTreeHashResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *LogTreeHashResponse) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *LogTreeHashResponse) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

type MapTreeHashRequest struct {
	Map      *MapRef `protobuf:"bytes,1,opt,name=map" json:"map,omitempty"`
	TreeSize int64   `protobuf:"varint,2,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
}

func (m *MapTreeHashRequest) Reset()                    { *m = MapTreeHashRequest{} }
func (m *MapTreeHashRequest) String() string            { return proto.CompactTextString(m) }
func (*MapTreeHashRequest) ProtoMessage()               {}
func (*MapTreeHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *MapTreeHashRequest) GetMap() *MapRef {
	if m != nil {
		return m.Map
	}
	return nil
}

func (m *MapTreeHashRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

type MapTreeHashResponse struct {
	RootHash    []byte               `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	MutationLog *LogTreeHashResponse `protobuf:"bytes,2,opt,name=mutation_log,json=mutationLog" json:"mutation_log,omitempty"`
}

func (m *MapTreeHashResponse) Reset()                    { *m = MapTreeHashResponse{} }
func (m *MapTreeHashResponse) String() string            { return proto.CompactTextString(m) }
func (*MapTreeHashResponse) ProtoMessage()               {}
func (*MapTreeHashResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *MapTreeHashResponse) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *MapTreeHashResponse) GetMutationLog() *LogTreeHashResponse {
	if m != nil {
		return m.MutationLog
	}
	return nil
}

type LogInclusionProofRequest struct {
	Log      *LogRef `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
	TreeSize int64   `protobuf:"varint,2,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	// One of:
	MtlHash   []byte `protobuf:"bytes,3,opt,name=mtl_hash,json=mtlHash,proto3" json:"mtl_hash,omitempty"`
	LeafIndex int64  `protobuf:"varint,4,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
}

func (m *LogInclusionProofRequest) Reset()                    { *m = LogInclusionProofRequest{} }
func (m *LogInclusionProofRequest) String() string            { return proto.CompactTextString(m) }
func (*LogInclusionProofRequest) ProtoMessage()               {}
func (*LogInclusionProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *LogInclusionProofRequest) GetLog() *LogRef {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogInclusionProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *LogInclusionProofRequest) GetMtlHash() []byte {
	if m != nil {
		return m.MtlHash
	}
	return nil
}

func (m *LogInclusionProofRequest) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

type LogInclusionProofResponse struct {
	TreeSize  int64    `protobuf:"varint,1,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	LeafIndex int64    `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	AuditPath [][]byte `protobuf:"bytes,3,rep,name=audit_path,json=auditPath,proto3" json:"audit_path,omitempty"`
}

func (m *LogInclusionProofResponse) Reset()                    { *m = LogInclusionProofResponse{} }
func (m *LogInclusionProofResponse) String() string            { return proto.CompactTextString(m) }
func (*LogInclusionProofResponse) ProtoMessage()               {}
func (*LogInclusionProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *LogInclusionProofResponse) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *LogInclusionProofResponse) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *LogInclusionProofResponse) GetAuditPath() [][]byte {
	if m != nil {
		return m.AuditPath
	}
	return nil
}

type LogConsistencyProofRequest struct {
	Log      *LogRef `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
	FromSize int64   `protobuf:"varint,2,opt,name=from_size,json=fromSize" json:"from_size,omitempty"`
	TreeSize int64   `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
}

func (m *LogConsistencyProofRequest) Reset()                    { *m = LogConsistencyProofRequest{} }
func (m *LogConsistencyProofRequest) String() string            { return proto.CompactTextString(m) }
func (*LogConsistencyProofRequest) ProtoMessage()               {}
func (*LogConsistencyProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *LogConsistencyProofRequest) GetLog() *LogRef {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogConsistencyProofRequest) GetFromSize() int64 {
	if m != nil {
		return m.FromSize
	}
	return 0
}

func (m *LogConsistencyProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

type LogConsistencyProofResponse struct {
	FromSize  int64    `protobuf:"varint,1,opt,name=from_size,json=fromSize" json:"from_size,omitempty"`
	TreeSize  int64    `protobuf:"varint,2,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	AuditPath [][]byte `protobuf:"bytes,3,rep,name=audit_path,json=auditPath,proto3" json:"audit_path,omitempty"`
}

func (m *LogConsistencyProofResponse) Reset()                    { *m = LogConsistencyProofResponse{} }
func (m *LogConsistencyProofResponse) String() string            { return proto.CompactTextString(m) }
func (*LogConsistencyProofResponse) ProtoMessage()               {}
func (*LogConsistencyProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *LogConsistencyProofResponse) GetFromSize() int64 {
	if m != nil {
		return m.FromSize
	}
	return 0
}

func (m *LogConsistencyProofResponse) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *LogConsistencyProofResponse) GetAuditPath() [][]byte {
	if m != nil {
		return m.AuditPath
	}
	return nil
}

type LeafData struct {
	LeafInput []byte     `protobuf:"bytes,1,opt,name=leaf_input,json=leafInput,proto3" json:"leaf_input,omitempty"`
	ExtraData []byte     `protobuf:"bytes,2,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	Format    DataFormat `protobuf:"varint,3,opt,name=format,enum=com.continusec.verifiabledatastructures.api.DataFormat" json:"format,omitempty"`
}

func (m *LeafData) Reset()                    { *m = LeafData{} }
func (m *LeafData) String() string            { return proto.CompactTextString(m) }
func (*LeafData) ProtoMessage()               {}
func (*LeafData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *LeafData) GetLeafInput() []byte {
	if m != nil {
		return m.LeafInput
	}
	return nil
}

func (m *LeafData) GetExtraData() []byte {
	if m != nil {
		return m.ExtraData
	}
	return nil
}

func (m *LeafData) GetFormat() DataFormat {
	if m != nil {
		return m.Format
	}
	return DataFormat_UNSPECIFIED
}

type LogAddEntryRequest struct {
	Log   *LogRef   `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
	Value *LeafData `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *LogAddEntryRequest) Reset()                    { *m = LogAddEntryRequest{} }
func (m *LogAddEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*LogAddEntryRequest) ProtoMessage()               {}
func (*LogAddEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *LogAddEntryRequest) GetLog() *LogRef {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogAddEntryRequest) GetValue() *LeafData {
	if m != nil {
		return m.Value
	}
	return nil
}

type LogAddEntryResponse struct {
	LeafHash []byte `protobuf:"bytes,1,opt,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
}

func (m *LogAddEntryResponse) Reset()                    { *m = LogAddEntryResponse{} }
func (m *LogAddEntryResponse) String() string            { return proto.CompactTextString(m) }
func (*LogAddEntryResponse) ProtoMessage()               {}
func (*LogAddEntryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *LogAddEntryResponse) GetLeafHash() []byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

type MapSetValueRequest struct {
	Map      *MapRef      `protobuf:"bytes,1,opt,name=map" json:"map,omitempty"`
	Mutation *MapMutation `protobuf:"bytes,2,opt,name=mutation" json:"mutation,omitempty"`
}

func (m *MapSetValueRequest) Reset()                    { *m = MapSetValueRequest{} }
func (m *MapSetValueRequest) String() string            { return proto.CompactTextString(m) }
func (*MapSetValueRequest) ProtoMessage()               {}
func (*MapSetValueRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *MapSetValueRequest) GetMap() *MapRef {
	if m != nil {
		return m.Map
	}
	return nil
}

func (m *MapSetValueRequest) GetMutation() *MapMutation {
	if m != nil {
		return m.Mutation
	}
	return nil
}

type MapSetValueResponse struct {
	LeafHash []byte `protobuf:"bytes,1,opt,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
}

func (m *MapSetValueResponse) Reset()                    { *m = MapSetValueResponse{} }
func (m *MapSetValueResponse) String() string            { return proto.CompactTextString(m) }
func (*MapSetValueResponse) ProtoMessage()               {}
func (*MapSetValueResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *MapSetValueResponse) GetLeafHash() []byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

type MapGetValueRequest struct {
	Map      *MapRef `protobuf:"bytes,1,opt,name=map" json:"map,omitempty"`
	TreeSize int64   `protobuf:"varint,2,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	Key      []byte  `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *MapGetValueRequest) Reset()                    { *m = MapGetValueRequest{} }
func (m *MapGetValueRequest) String() string            { return proto.CompactTextString(m) }
func (*MapGetValueRequest) ProtoMessage()               {}
func (*MapGetValueRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *MapGetValueRequest) GetMap() *MapRef {
	if m != nil {
		return m.Map
	}
	return nil
}

func (m *MapGetValueRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *MapGetValueRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type MapGetValueResponse struct {
	TreeSize  int64     `protobuf:"varint,1,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	AuditPath [][]byte  `protobuf:"bytes,2,rep,name=audit_path,json=auditPath,proto3" json:"audit_path,omitempty"`
	Value     *LeafData `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *MapGetValueResponse) Reset()                    { *m = MapGetValueResponse{} }
func (m *MapGetValueResponse) String() string            { return proto.CompactTextString(m) }
func (*MapGetValueResponse) ProtoMessage()               {}
func (*MapGetValueResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *MapGetValueResponse) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *MapGetValueResponse) GetAuditPath() [][]byte {
	if m != nil {
		return m.AuditPath
	}
	return nil
}

func (m *MapGetValueResponse) GetValue() *LeafData {
	if m != nil {
		return m.Value
	}
	return nil
}

type LogFetchEntriesRequest struct {
	Log   *LogRef `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
	First int64   `protobuf:"varint,2,opt,name=first" json:"first,omitempty"`
	Last  int64   `protobuf:"varint,3,opt,name=last" json:"last,omitempty"`
}

func (m *LogFetchEntriesRequest) Reset()                    { *m = LogFetchEntriesRequest{} }
func (m *LogFetchEntriesRequest) String() string            { return proto.CompactTextString(m) }
func (*LogFetchEntriesRequest) ProtoMessage()               {}
func (*LogFetchEntriesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *LogFetchEntriesRequest) GetLog() *LogRef {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogFetchEntriesRequest) GetFirst() int64 {
	if m != nil {
		return m.First
	}
	return 0
}

func (m *LogFetchEntriesRequest) GetLast() int64 {
	if m != nil {
		return m.Last
	}
	return 0
}

type LogFetchEntriesResponse struct {
	Values []*LeafData `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *LogFetchEntriesResponse) Reset()                    { *m = LogFetchEntriesResponse{} }
func (m *LogFetchEntriesResponse) String() string            { return proto.CompactTextString(m) }
func (*LogFetchEntriesResponse) ProtoMessage()               {}
func (*LogFetchEntriesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *LogFetchEntriesResponse) GetValues() []*LeafData {
	if m != nil {
		return m.Values
	}
	return nil
}

type MapMutation struct {
	Timestamp        string    `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Action           string    `protobuf:"bytes,2,opt,name=action" json:"action,omitempty"`
	Key              []byte    `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Value            *LeafData `protobuf:"bytes,4,opt,name=value" json:"value,omitempty"`
	PreviousLeafHash []byte    `protobuf:"bytes,5,opt,name=previous_leaf_hash,json=previousLeafHash,proto3" json:"previous_leaf_hash,omitempty"`
}

func (m *MapMutation) Reset()                    { *m = MapMutation{} }
func (m *MapMutation) String() string            { return proto.CompactTextString(m) }
func (*MapMutation) ProtoMessage()               {}
func (*MapMutation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *MapMutation) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *MapMutation) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *MapMutation) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *MapMutation) GetValue() *LeafData {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *MapMutation) GetPreviousLeafHash() []byte {
	if m != nil {
		return m.PreviousLeafHash
	}
	return nil
}

func init() {
	proto.RegisterType((*AccountRef)(nil), "com.continusec.verifiabledatastructures.api.AccountRef")
	proto.RegisterType((*LogRef)(nil), "com.continusec.verifiabledatastructures.api.LogRef")
	proto.RegisterType((*MapRef)(nil), "com.continusec.verifiabledatastructures.api.MapRef")
	proto.RegisterType((*LogTreeHashRequest)(nil), "com.continusec.verifiabledatastructures.api.LogTreeHashRequest")
	proto.RegisterType((*LogTreeHashResponse)(nil), "com.continusec.verifiabledatastructures.api.LogTreeHashResponse")
	proto.RegisterType((*MapTreeHashRequest)(nil), "com.continusec.verifiabledatastructures.api.MapTreeHashRequest")
	proto.RegisterType((*MapTreeHashResponse)(nil), "com.continusec.verifiabledatastructures.api.MapTreeHashResponse")
	proto.RegisterType((*LogInclusionProofRequest)(nil), "com.continusec.verifiabledatastructures.api.LogInclusionProofRequest")
	proto.RegisterType((*LogInclusionProofResponse)(nil), "com.continusec.verifiabledatastructures.api.LogInclusionProofResponse")
	proto.RegisterType((*LogConsistencyProofRequest)(nil), "com.continusec.verifiabledatastructures.api.LogConsistencyProofRequest")
	proto.RegisterType((*LogConsistencyProofResponse)(nil), "com.continusec.verifiabledatastructures.api.LogConsistencyProofResponse")
	proto.RegisterType((*LeafData)(nil), "com.continusec.verifiabledatastructures.api.LeafData")
	proto.RegisterType((*LogAddEntryRequest)(nil), "com.continusec.verifiabledatastructures.api.LogAddEntryRequest")
	proto.RegisterType((*LogAddEntryResponse)(nil), "com.continusec.verifiabledatastructures.api.LogAddEntryResponse")
	proto.RegisterType((*MapSetValueRequest)(nil), "com.continusec.verifiabledatastructures.api.MapSetValueRequest")
	proto.RegisterType((*MapSetValueResponse)(nil), "com.continusec.verifiabledatastructures.api.MapSetValueResponse")
	proto.RegisterType((*MapGetValueRequest)(nil), "com.continusec.verifiabledatastructures.api.MapGetValueRequest")
	proto.RegisterType((*MapGetValueResponse)(nil), "com.continusec.verifiabledatastructures.api.MapGetValueResponse")
	proto.RegisterType((*LogFetchEntriesRequest)(nil), "com.continusec.verifiabledatastructures.api.LogFetchEntriesRequest")
	proto.RegisterType((*LogFetchEntriesResponse)(nil), "com.continusec.verifiabledatastructures.api.LogFetchEntriesResponse")
	proto.RegisterType((*MapMutation)(nil), "com.continusec.verifiabledatastructures.api.MapMutation")
	proto.RegisterEnum("com.continusec.verifiabledatastructures.api.LogType", LogType_name, LogType_value)
	proto.RegisterEnum("com.continusec.verifiabledatastructures.api.DataFormat", DataFormat_name, DataFormat_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for VerifiableDataStructuresService service

type VerifiableDataStructuresServiceClient interface {
	LogAddEntry(ctx context.Context, in *LogAddEntryRequest, opts ...grpc.CallOption) (*LogAddEntryResponse, error)
	LogFetchEntries(ctx context.Context, in *LogFetchEntriesRequest, opts ...grpc.CallOption) (*LogFetchEntriesResponse, error)
	LogTreeHash(ctx context.Context, in *LogTreeHashRequest, opts ...grpc.CallOption) (*LogTreeHashResponse, error)
	LogInclusionProof(ctx context.Context, in *LogInclusionProofRequest, opts ...grpc.CallOption) (*LogInclusionProofResponse, error)
	LogConsistencyProof(ctx context.Context, in *LogConsistencyProofRequest, opts ...grpc.CallOption) (*LogConsistencyProofResponse, error)
	MapSetValue(ctx context.Context, in *MapSetValueRequest, opts ...grpc.CallOption) (*MapSetValueResponse, error)
	MapGetValue(ctx context.Context, in *MapGetValueRequest, opts ...grpc.CallOption) (*MapGetValueResponse, error)
	MapTreeHash(ctx context.Context, in *MapTreeHashRequest, opts ...grpc.CallOption) (*MapTreeHashResponse, error)
}

type verifiableDataStructuresServiceClient struct {
	cc *grpc.ClientConn
}

func NewVerifiableDataStructuresServiceClient(cc *grpc.ClientConn) VerifiableDataStructuresServiceClient {
	return &verifiableDataStructuresServiceClient{cc}
}

func (c *verifiableDataStructuresServiceClient) LogAddEntry(ctx context.Context, in *LogAddEntryRequest, opts ...grpc.CallOption) (*LogAddEntryResponse, error) {
	out := new(LogAddEntryResponse)
	err := grpc.Invoke(ctx, "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogAddEntry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) LogFetchEntries(ctx context.Context, in *LogFetchEntriesRequest, opts ...grpc.CallOption) (*LogFetchEntriesResponse, error) {
	out := new(LogFetchEntriesResponse)
	err := grpc.Invoke(ctx, "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogFetchEntries", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) LogTreeHash(ctx context.Context, in *LogTreeHashRequest, opts ...grpc.CallOption) (*LogTreeHashResponse, error) {
	out := new(LogTreeHashResponse)
	err := grpc.Invoke(ctx, "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogTreeHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) LogInclusionProof(ctx context.Context, in *LogInclusionProofRequest, opts ...grpc.CallOption) (*LogInclusionProofResponse, error) {
	out := new(LogInclusionProofResponse)
	err := grpc.Invoke(ctx, "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogInclusionProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) LogConsistencyProof(ctx context.Context, in *LogConsistencyProofRequest, opts ...grpc.CallOption) (*LogConsistencyProofResponse, error) {
	out := new(LogConsistencyProofResponse)
	err := grpc.Invoke(ctx, "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogConsistencyProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) MapSetValue(ctx context.Context, in *MapSetValueRequest, opts ...grpc.CallOption) (*MapSetValueResponse, error) {
	out := new(MapSetValueResponse)
	err := grpc.Invoke(ctx, "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapSetValue", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) MapGetValue(ctx context.Context, in *MapGetValueRequest, opts ...grpc.CallOption) (*MapGetValueResponse, error) {
	out := new(MapGetValueResponse)
	err := grpc.Invoke(ctx, "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapGetValue", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) MapTreeHash(ctx context.Context, in *MapTreeHashRequest, opts ...grpc.CallOption) (*MapTreeHashResponse, error) {
	out := new(MapTreeHashResponse)
	err := grpc.Invoke(ctx, "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapTreeHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VerifiableDataStructuresService service

type VerifiableDataStructuresServiceServer interface {
	LogAddEntry(context.Context, *LogAddEntryRequest) (*LogAddEntryResponse, error)
	LogFetchEntries(context.Context, *LogFetchEntriesRequest) (*LogFetchEntriesResponse, error)
	LogTreeHash(context.Context, *LogTreeHashRequest) (*LogTreeHashResponse, error)
	LogInclusionProof(context.Context, *LogInclusionProofRequest) (*LogInclusionProofResponse, error)
	LogConsistencyProof(context.Context, *LogConsistencyProofRequest) (*LogConsistencyProofResponse, error)
	MapSetValue(context.Context, *MapSetValueRequest) (*MapSetValueResponse, error)
	MapGetValue(context.Context, *MapGetValueRequest) (*MapGetValueResponse, error)
	MapTreeHash(context.Context, *MapTreeHashRequest) (*MapTreeHashResponse, error)
}

func RegisterVerifiableDataStructuresServiceServer(s *grpc.Server, srv VerifiableDataStructuresServiceServer) {
	s.RegisterService(&_VerifiableDataStructuresService_serviceDesc, srv)
}

func _VerifiableDataStructuresService_LogAddEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogAddEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).LogAddEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogAddEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).LogAddEntry(ctx, req.(*LogAddEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_LogFetchEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogFetchEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).LogFetchEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogFetchEntries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).LogFetchEntries(ctx, req.(*LogFetchEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_LogTreeHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogTreeHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).LogTreeHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogTreeHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).LogTreeHash(ctx, req.(*LogTreeHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_LogInclusionProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogInclusionProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).LogInclusionProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogInclusionProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).LogInclusionProof(ctx, req.(*LogInclusionProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_LogConsistencyProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogConsistencyProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).LogConsistencyProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogConsistencyProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).LogConsistencyProof(ctx, req.(*LogConsistencyProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_MapSetValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapSetValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).MapSetValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapSetValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).MapSetValue(ctx, req.(*MapSetValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_MapGetValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapGetValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).MapGetValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapGetValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).MapGetValue(ctx, req.(*MapGetValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_MapTreeHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapTreeHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).MapTreeHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapTreeHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).MapTreeHash(ctx, req.(*MapTreeHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VerifiableDataStructuresService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "com.continusec.verifiabledatastructures.api.VerifiableDataStructuresService",
	HandlerType: (*VerifiableDataStructuresServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LogAddEntry",
			Handler:    _VerifiableDataStructuresService_LogAddEntry_Handler,
		},
		{
			MethodName: "LogFetchEntries",
			Handler:    _VerifiableDataStructuresService_LogFetchEntries_Handler,
		},
		{
			MethodName: "LogTreeHash",
			Handler:    _VerifiableDataStructuresService_LogTreeHash_Handler,
		},
		{
			MethodName: "LogInclusionProof",
			Handler:    _VerifiableDataStructuresService_LogInclusionProof_Handler,
		},
		{
			MethodName: "LogConsistencyProof",
			Handler:    _VerifiableDataStructuresService_LogConsistencyProof_Handler,
		},
		{
			MethodName: "MapSetValue",
			Handler:    _VerifiableDataStructuresService_MapSetValue_Handler,
		},
		{
			MethodName: "MapGetValue",
			Handler:    _VerifiableDataStructuresService_MapGetValue_Handler,
		},
		{
			MethodName: "MapTreeHash",
			Handler:    _VerifiableDataStructuresService_MapTreeHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1079 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x58, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xd8, 0xa9, 0x63, 0x3f, 0x47, 0x89, 0x99, 0xa0, 0xd6, 0x75, 0x8b, 0xa8, 0xf6, 0x42,
	0x55, 0x90, 0x23, 0x12, 0x2a, 0xb8, 0xd1, 0x90, 0x38, 0x8e, 0xa9, 0x1d, 0x87, 0xb5, 0x53, 0x89,
	0x5e, 0x56, 0x93, 0xf5, 0xd8, 0x1e, 0xb1, 0xbb, 0xb3, 0xec, 0xce, 0x5a, 0x71, 0xbf, 0x01, 0x1c,
	0xb9, 0x20, 0x0e, 0xf4, 0xc4, 0x01, 0x71, 0xe3, 0xc6, 0x91, 0x8f, 0xc0, 0x37, 0x02, 0xcd, 0xec,
	0xda, 0xeb, 0x7f, 0xb1, 0xba, 0x76, 0xc2, 0x6d, 0xfd, 0x46, 0xef, 0xf7, 0xde, 0xef, 0xf7, 0xde,
	0xbc, 0x79, 0x09, 0xe4, 0x88, 0xcb, 0xca, 0xae, 0xc7, 0x05, 0xc7, 0x1f, 0x9b, 0xdc, 0x2e, 0x9b,
	0xdc, 0x11, 0xcc, 0x09, 0x7c, 0x6a, 0x96, 0x07, 0xd4, 0x63, 0x5d, 0x46, 0xae, 0x2c, 0xda, 0x21,
	0x82, 0xf8, 0xc2, 0x0b, 0x4c, 0x11, 0x78, 0xd4, 0x2f, 0x13, 0x97, 0x69, 0xcf, 0x01, 0x8e, 0x4c,
	0x93, 0x07, 0x8e, 0xd0, 0x69, 0x17, 0xef, 0x40, 0x8a, 0x75, 0x8a, 0xe8, 0x09, 0x7a, 0x9a, 0xd3,
	0x53, 0xac, 0x83, 0x1f, 0xc0, 0x16, 0x71, 0x99, 0xf1, 0x1d, 0x1d, 0x16, 0x53, 0xca, 0x98, 0x21,
	0x2e, 0x7b, 0x49, 0x87, 0xda, 0xdf, 0x08, 0x32, 0x75, 0xde, 0x93, 0x3e, 0xdf, 0xc0, 0x16, 0x09,
	0x11, 0x94, 0x63, 0xfe, 0xe0, 0xf3, 0x72, 0x82, 0x04, 0xca, 0x71, 0x74, 0x7d, 0x84, 0x83, 0x9b,
	0x90, 0xb5, 0x78, 0xcf, 0x10, 0x43, 0x97, 0xaa, 0xb8, 0x3b, 0x07, 0x9f, 0x25, 0xc2, 0xac, 0xf3,
	0x5e, 0x7b, 0xe8, 0x52, 0x7d, 0xcb, 0x0a, 0x3f, 0x30, 0x86, 0x4d, 0x87, 0xd8, 0xb4, 0x98, 0x56,
	0x24, 0xd4, 0xb7, 0xc6, 0x21, 0xd3, 0x20, 0xee, 0x1d, 0x31, 0x58, 0x14, 0xf0, 0x1a, 0xb0, 0x4c,
	0xcc, 0xa3, 0xf4, 0x8c, 0xf8, 0x7d, 0x9d, 0x7e, 0x1f, 0x50, 0x5f, 0xe0, 0x0a, 0xa4, 0x2d, 0xde,
	0x8b, 0x02, 0x1f, 0x26, 0xa5, 0x29, 0x83, 0x4a, 0x7f, 0xfc, 0x08, 0x72, 0xc2, 0xa3, 0xd4, 0xf0,
	0xd9, 0x9b, 0x50, 0xb3, 0xb4, 0x9e, 0x95, 0x86, 0x16, 0x7b, 0x43, 0xb5, 0x26, 0xec, 0x4d, 0x45,
	0xf6, 0x5d, 0xee, 0xf8, 0x74, 0xda, 0x07, 0x4d, 0xfb, 0xc8, 0x43, 0x8f, 0x73, 0x61, 0xf4, 0x89,
	0xdf, 0x57, 0x80, 0xdb, 0x7a, 0x56, 0x1a, 0x24, 0x82, 0xa4, 0xd2, 0x20, 0xee, 0x02, 0x2a, 0x36,
	0x71, 0x57, 0xa2, 0x12, 0x56, 0x42, 0x97, 0xfe, 0xcb, 0xa9, 0xfc, 0x8c, 0x60, 0x6f, 0x2a, 0x74,
	0xcc, 0x25, 0x4e, 0x17, 0x4d, 0xa7, 0x8b, 0x4d, 0xd8, 0xb6, 0x03, 0x41, 0x04, 0xe3, 0x8e, 0x21,
	0xc5, 0x4e, 0xa9, 0x0c, 0x5f, 0x24, 0xee, 0xa9, 0x99, 0xa0, 0x7a, 0x7e, 0x84, 0x5a, 0xe7, 0x3d,
	0xed, 0x2f, 0x04, 0xc5, 0x3a, 0xef, 0xd5, 0x1c, 0xd3, 0x0a, 0x7c, 0xc6, 0x9d, 0x0b, 0x8f, 0xf3,
	0xee, 0xff, 0x58, 0x65, 0xfc, 0x10, 0xb2, 0xb6, 0xb0, 0x42, 0x05, 0xd2, 0x4a, 0x81, 0x2d, 0x5b,
	0x58, 0x4a, 0x80, 0x0f, 0x00, 0x2c, 0x4a, 0xba, 0x06, 0x73, 0x3a, 0xf4, 0xba, 0xb8, 0xa9, 0x1c,
	0x73, 0xd2, 0x52, 0x93, 0x06, 0x6d, 0x00, 0x0f, 0x17, 0x64, 0xfe, 0x2e, 0x5d, 0x32, 0x0d, 0x9c,
	0x9a, 0x01, 0x96, 0xc7, 0x24, 0xe8, 0x30, 0x61, 0xb8, 0x44, 0xc8, 0xa4, 0xd2, 0x4f, 0xb7, 0xf5,
	0x9c, 0xb2, 0x5c, 0x10, 0xd1, 0xd7, 0x7e, 0x45, 0x50, 0xaa, 0xf3, 0xde, 0x31, 0x77, 0x7c, 0xe6,
	0x0b, 0xea, 0x98, 0xc3, 0x3b, 0x12, 0xad, 0xeb, 0x71, 0x7b, 0x4a, 0x34, 0x69, 0x18, 0xb5, 0x79,
	0xcc, 0x2e, 0x3d, 0xd3, 0x6c, 0x03, 0x78, 0xb4, 0x30, 0xbd, 0x58, 0x99, 0x18, 0x18, 0x2d, 0x03,
	0x4e, 0xcd, 0xcb, 0xb6, 0x4c, 0x97, 0x5f, 0x10, 0x64, 0xeb, 0x94, 0x74, 0x4f, 0x88, 0x20, 0x13,
	0x12, 0xbb, 0x81, 0x88, 0x5a, 0x3b, 0x92, 0xd8, 0x0d, 0x84, 0x3c, 0xa6, 0xd7, 0xc2, 0x23, 0x86,
	0x54, 0x21, 0xba, 0xa8, 0x39, 0x65, 0x51, 0xde, 0x4d, 0xc8, 0x74, 0xb9, 0x67, 0x13, 0xa1, 0xc8,
	0xed, 0x24, 0x1c, 0x6d, 0x12, 0xe2, 0x54, 0xb9, 0xeb, 0x11, 0x8c, 0xf6, 0x3b, 0x52, 0x63, 0xec,
	0xa8, 0xd3, 0xa9, 0x38, 0xc2, 0x1b, 0xde, 0x72, 0xad, 0x5e, 0xc2, 0xbd, 0x01, 0xb1, 0x02, 0x1a,
	0x5d, 0xd1, 0xe7, 0xc9, 0x80, 0x22, 0xc9, 0xf4, 0x10, 0x43, 0x3b, 0x50, 0x63, 0x2f, 0xce, 0x34,
	0x2e, 0x9b, 0x12, 0x74, 0x72, 0x54, 0x48, 0x83, 0x9a, 0x6c, 0x7f, 0x22, 0x35, 0xda, 0x5a, 0x54,
	0xbc, 0x92, 0x18, 0xb7, 0x3c, 0xda, 0xda, 0x90, 0x1d, 0x8d, 0x8c, 0x88, 0xe1, 0x17, 0x49, 0xb1,
	0x1a, 0x91, 0xbf, 0x3e, 0x46, 0x92, 0x3c, 0xa7, 0x52, 0x7e, 0x17, 0x9e, 0x3f, 0x86, 0x3c, 0xab,
	0x77, 0xc3, 0x73, 0x69, 0xf3, 0x17, 0x20, 0x2d, 0x17, 0x8a, 0x70, 0x44, 0xc9, 0x4f, 0xed, 0x6d,
	0x38, 0xd4, 0xab, 0x0b, 0x18, 0x2c, 0x1d, 0x3d, 0x13, 0x77, 0x28, 0x35, 0x73, 0x87, 0xe2, 0x4e,
	0x4a, 0xdf, 0x42, 0x27, 0xfd, 0x80, 0xe0, 0x7e, 0x9d, 0xf7, 0x4e, 0xa9, 0x30, 0xfb, 0xb2, 0x99,
	0x18, 0xf5, 0x6f, 0xb9, 0xf1, 0xdf, 0x87, 0x7b, 0x5d, 0xe6, 0xf9, 0x22, 0x52, 0x2b, 0xfc, 0x21,
	0xd7, 0x08, 0x8b, 0xf8, 0x22, 0x1a, 0x4c, 0xea, 0x5b, 0xeb, 0xc3, 0x83, 0xb9, 0x54, 0x22, 0xbd,
	0x1a, 0x90, 0x51, 0xf9, 0xfa, 0x45, 0xf4, 0x24, 0xbd, 0x3a, 0xe9, 0x08, 0x44, 0xfb, 0x07, 0x41,
	0x7e, 0xa2, 0xe3, 0xf0, 0x63, 0xc8, 0x09, 0x66, 0x53, 0x5f, 0x10, 0xdb, 0x8d, 0x96, 0xc4, 0xd8,
	0x80, 0xef, 0x43, 0x86, 0x98, 0xe3, 0xce, 0x96, 0xab, 0xa2, 0xfa, 0x35, 0x5f, 0xee, 0xb8, 0x34,
	0x9b, 0xeb, 0x97, 0x06, 0x7f, 0x02, 0xd8, 0xf5, 0xe8, 0x80, 0xf1, 0xc0, 0x37, 0xe2, 0x76, 0xbf,
	0xa7, 0xa2, 0x15, 0x46, 0x27, 0xf5, 0xa8, 0xed, 0x9f, 0xbd, 0x86, 0xad, 0x68, 0x39, 0xc4, 0x7b,
	0xb0, 0xdb, 0x6a, 0xeb, 0x97, 0xc7, 0x6d, 0xa3, 0xfd, 0xed, 0x45, 0xc5, 0xa8, 0x37, 0xab, 0x85,
	0x0d, 0xfc, 0x18, 0x8a, 0x93, 0xc6, 0xc6, 0x65, 0xfb, 0xa8, 0x5d, 0x6b, 0x9e, 0xab, 0x53, 0x34,
	0x7b, 0xda, 0xd6, 0x2b, 0x95, 0xb3, 0xca, 0xd1, 0x89, 0x3a, 0x4d, 0x3d, 0xfb, 0x08, 0x20, 0x9e,
	0x97, 0x78, 0x17, 0xf2, 0x97, 0xe7, 0xad, 0x8b, 0xca, 0x71, 0xed, 0xb4, 0x56, 0x39, 0x29, 0x6c,
	0xe0, 0x2c, 0x6c, 0x7e, 0xdd, 0x6a, 0x9e, 0x17, 0xd0, 0xc1, 0xbf, 0x39, 0xf8, 0xf0, 0xd5, 0x98,
	0xa3, 0xf4, 0x69, 0x8d, 0x39, 0xb6, 0xa8, 0x37, 0x60, 0x26, 0xc5, 0x3f, 0x21, 0xc8, 0x4f, 0x0c,
	0x2f, 0xfc, 0x65, 0xd2, 0xce, 0x9a, 0x19, 0xd0, 0xa5, 0x17, 0xab, 0x03, 0x84, 0xdd, 0xa5, 0x6d,
	0xe0, 0xb7, 0x08, 0x76, 0x67, 0x7a, 0x0f, 0x1f, 0x27, 0xc5, 0x5d, 0x70, 0x89, 0x4a, 0x27, 0xeb,
	0x81, 0x8c, 0x13, 0x8c, 0x54, 0x1b, 0x2d, 0x6a, 0xc9, 0x55, 0x9b, 0x59, 0x69, 0x4b, 0x6b, 0xef,
	0x88, 0xda, 0x06, 0xfe, 0x0d, 0xc1, 0x7b, 0x73, 0xeb, 0x15, 0xae, 0x24, 0x45, 0x5e, 0xb8, 0x58,
	0x96, 0x4e, 0xd7, 0x85, 0x19, 0xa7, 0xf9, 0x07, 0x52, 0xcf, 0xe5, 0xec, 0xb6, 0x83, 0xab, 0x49,
	0x23, 0xdc, 0xb0, 0xce, 0x95, 0xce, 0xd6, 0x07, 0x9a, 0x2a, 0xf4, 0xc4, 0x9b, 0x97, 0xb0, 0xd0,
	0xf3, 0x0f, 0x7c, 0xc2, 0x42, 0x2f, 0x78, 0x6e, 0xe3, 0xa4, 0xaa, 0x2b, 0x27, 0x55, 0x5d, 0x37,
	0xa9, 0xea, 0x8d, 0x49, 0xad, 0x78, 0x25, 0xe6, 0xff, 0xca, 0x4b, 0x9e, 0xd4, 0xfc, 0x95, 0xf8,
	0xea, 0xf0, 0xf5, 0xa7, 0x3d, 0x26, 0xfa, 0xc1, 0x95, 0xc4, 0xda, 0x8f, 0xb1, 0xf6, 0x6f, 0xc2,
	0xda, 0x77, 0xaf, 0xae, 0x32, 0xea, 0xdf, 0x1b, 0x87, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0xd0,
	0xf8, 0xdc, 0x0c, 0xeb, 0x10, 0x00, 0x00,
}
