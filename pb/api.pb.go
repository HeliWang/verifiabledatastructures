// Code generated by protoc-gen-go.
// source: api.proto
// DO NOT EDIT!

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type LogType int32

const (
	LogType_STRUCT_TYPE_LOG          LogType = 0
	LogType_STRUCT_TYPE_MUTATION_LOG LogType = 1
	LogType_STRUCT_TYPE_TREEHEAD_LOG LogType = 2
)

var LogType_name = map[int32]string{
	0: "STRUCT_TYPE_LOG",
	1: "STRUCT_TYPE_MUTATION_LOG",
	2: "STRUCT_TYPE_TREEHEAD_LOG",
}
var LogType_value = map[string]int32{
	"STRUCT_TYPE_LOG":          0,
	"STRUCT_TYPE_MUTATION_LOG": 1,
	"STRUCT_TYPE_TREEHEAD_LOG": 2,
}

func (x LogType) String() string {
	return proto.EnumName(LogType_name, int32(x))
}
func (LogType) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

type DataFormat int32

const (
	DataFormat_UNSPECIFIED DataFormat = 0
	DataFormat_JSON        DataFormat = 1
)

var DataFormat_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "JSON",
}
var DataFormat_value = map[string]int32{
	"UNSPECIFIED": 0,
	"JSON":        1,
}

func (x DataFormat) String() string {
	return proto.EnumName(DataFormat_name, int32(x))
}
func (DataFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

type AccountRef struct {
	Id     string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	ApiKey string `protobuf:"bytes,2,opt,name=api_key,json=apiKey" json:"api_key,omitempty"`
}

func (m *AccountRef) Reset()                    { *m = AccountRef{} }
func (m *AccountRef) String() string            { return proto.CompactTextString(m) }
func (*AccountRef) ProtoMessage()               {}
func (*AccountRef) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *AccountRef) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AccountRef) GetApiKey() string {
	if m != nil {
		return m.ApiKey
	}
	return ""
}

type LogRef struct {
	Account *AccountRef `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	LogType LogType     `protobuf:"varint,2,opt,name=log_type,json=logType,enum=continusec.verifiabledatastructures.api.LogType" json:"log_type,omitempty"`
	Name    string      `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *LogRef) Reset()                    { *m = LogRef{} }
func (m *LogRef) String() string            { return proto.CompactTextString(m) }
func (*LogRef) ProtoMessage()               {}
func (*LogRef) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *LogRef) GetAccount() *AccountRef {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *LogRef) GetLogType() LogType {
	if m != nil {
		return m.LogType
	}
	return LogType_STRUCT_TYPE_LOG
}

func (m *LogRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type MapRef struct {
	Account *AccountRef `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Name    string      `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *MapRef) Reset()                    { *m = MapRef{} }
func (m *MapRef) String() string            { return proto.CompactTextString(m) }
func (*MapRef) ProtoMessage()               {}
func (*MapRef) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *MapRef) GetAccount() *AccountRef {
	if m != nil {
		return m.Account
	}
	return nil
}

func (m *MapRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type LogTreeHashRequest struct {
	Log      *LogRef `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
	TreeSize int64   `protobuf:"varint,2,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
}

func (m *LogTreeHashRequest) Reset()                    { *m = LogTreeHashRequest{} }
func (m *LogTreeHashRequest) String() string            { return proto.CompactTextString(m) }
func (*LogTreeHashRequest) ProtoMessage()               {}
func (*LogTreeHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *LogTreeHashRequest) GetLog() *LogRef {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogTreeHashRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

type LogTreeHashResponse struct {
	TreeSize int64  `protobuf:"varint,1,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	RootHash []byte `protobuf:"bytes,2,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
}

func (m *LogTreeHashResponse) Reset()                    { *m = LogTreeHashResponse{} }
func (m *LogTreeHashResponse) String() string            { return proto.CompactTextString(m) }
func (*LogTreeHashResponse) ProtoMessage()               {}
func (*LogTreeHashResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{4} }

func (m *LogTreeHashResponse) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *LogTreeHashResponse) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

type MapTreeHashRequest struct {
	Map      *MapRef `protobuf:"bytes,1,opt,name=map" json:"map,omitempty"`
	TreeSize int64   `protobuf:"varint,2,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
}

func (m *MapTreeHashRequest) Reset()                    { *m = MapTreeHashRequest{} }
func (m *MapTreeHashRequest) String() string            { return proto.CompactTextString(m) }
func (*MapTreeHashRequest) ProtoMessage()               {}
func (*MapTreeHashRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{5} }

func (m *MapTreeHashRequest) GetMap() *MapRef {
	if m != nil {
		return m.Map
	}
	return nil
}

func (m *MapTreeHashRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

type MapTreeHashResponse struct {
	RootHash    []byte               `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	MutationLog *LogTreeHashResponse `protobuf:"bytes,2,opt,name=mutation_log,json=mutationLog" json:"mutation_log,omitempty"`
}

func (m *MapTreeHashResponse) Reset()                    { *m = MapTreeHashResponse{} }
func (m *MapTreeHashResponse) String() string            { return proto.CompactTextString(m) }
func (*MapTreeHashResponse) ProtoMessage()               {}
func (*MapTreeHashResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{6} }

func (m *MapTreeHashResponse) GetRootHash() []byte {
	if m != nil {
		return m.RootHash
	}
	return nil
}

func (m *MapTreeHashResponse) GetMutationLog() *LogTreeHashResponse {
	if m != nil {
		return m.MutationLog
	}
	return nil
}

type LogInclusionProofRequest struct {
	Log      *LogRef `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
	TreeSize int64   `protobuf:"varint,2,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	// One of:
	MtlHash   []byte `protobuf:"bytes,3,opt,name=mtl_hash,json=mtlHash,proto3" json:"mtl_hash,omitempty"`
	LeafIndex int64  `protobuf:"varint,4,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
}

func (m *LogInclusionProofRequest) Reset()                    { *m = LogInclusionProofRequest{} }
func (m *LogInclusionProofRequest) String() string            { return proto.CompactTextString(m) }
func (*LogInclusionProofRequest) ProtoMessage()               {}
func (*LogInclusionProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{7} }

func (m *LogInclusionProofRequest) GetLog() *LogRef {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogInclusionProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *LogInclusionProofRequest) GetMtlHash() []byte {
	if m != nil {
		return m.MtlHash
	}
	return nil
}

func (m *LogInclusionProofRequest) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

type LogInclusionProofResponse struct {
	TreeSize  int64    `protobuf:"varint,1,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	LeafIndex int64    `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex" json:"leaf_index,omitempty"`
	AuditPath [][]byte `protobuf:"bytes,3,rep,name=audit_path,json=auditPath,proto3" json:"audit_path,omitempty"`
}

func (m *LogInclusionProofResponse) Reset()                    { *m = LogInclusionProofResponse{} }
func (m *LogInclusionProofResponse) String() string            { return proto.CompactTextString(m) }
func (*LogInclusionProofResponse) ProtoMessage()               {}
func (*LogInclusionProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{8} }

func (m *LogInclusionProofResponse) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *LogInclusionProofResponse) GetLeafIndex() int64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *LogInclusionProofResponse) GetAuditPath() [][]byte {
	if m != nil {
		return m.AuditPath
	}
	return nil
}

type LogConsistencyProofRequest struct {
	Log      *LogRef `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
	FromSize int64   `protobuf:"varint,2,opt,name=from_size,json=fromSize" json:"from_size,omitempty"`
	TreeSize int64   `protobuf:"varint,3,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
}

func (m *LogConsistencyProofRequest) Reset()                    { *m = LogConsistencyProofRequest{} }
func (m *LogConsistencyProofRequest) String() string            { return proto.CompactTextString(m) }
func (*LogConsistencyProofRequest) ProtoMessage()               {}
func (*LogConsistencyProofRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{9} }

func (m *LogConsistencyProofRequest) GetLog() *LogRef {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogConsistencyProofRequest) GetFromSize() int64 {
	if m != nil {
		return m.FromSize
	}
	return 0
}

func (m *LogConsistencyProofRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

type LogConsistencyProofResponse struct {
	FromSize  int64    `protobuf:"varint,1,opt,name=from_size,json=fromSize" json:"from_size,omitempty"`
	TreeSize  int64    `protobuf:"varint,2,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	AuditPath [][]byte `protobuf:"bytes,3,rep,name=audit_path,json=auditPath,proto3" json:"audit_path,omitempty"`
}

func (m *LogConsistencyProofResponse) Reset()                    { *m = LogConsistencyProofResponse{} }
func (m *LogConsistencyProofResponse) String() string            { return proto.CompactTextString(m) }
func (*LogConsistencyProofResponse) ProtoMessage()               {}
func (*LogConsistencyProofResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{10} }

func (m *LogConsistencyProofResponse) GetFromSize() int64 {
	if m != nil {
		return m.FromSize
	}
	return 0
}

func (m *LogConsistencyProofResponse) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *LogConsistencyProofResponse) GetAuditPath() [][]byte {
	if m != nil {
		return m.AuditPath
	}
	return nil
}

type LeafData struct {
	LeafInput []byte     `protobuf:"bytes,1,opt,name=leaf_input,json=leafInput,proto3" json:"leaf_input,omitempty"`
	ExtraData []byte     `protobuf:"bytes,2,opt,name=extra_data,json=extraData,proto3" json:"extra_data,omitempty"`
	Format    DataFormat `protobuf:"varint,3,opt,name=format,enum=continusec.verifiabledatastructures.api.DataFormat" json:"format,omitempty"`
}

func (m *LeafData) Reset()                    { *m = LeafData{} }
func (m *LeafData) String() string            { return proto.CompactTextString(m) }
func (*LeafData) ProtoMessage()               {}
func (*LeafData) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{11} }

func (m *LeafData) GetLeafInput() []byte {
	if m != nil {
		return m.LeafInput
	}
	return nil
}

func (m *LeafData) GetExtraData() []byte {
	if m != nil {
		return m.ExtraData
	}
	return nil
}

func (m *LeafData) GetFormat() DataFormat {
	if m != nil {
		return m.Format
	}
	return DataFormat_UNSPECIFIED
}

type LogAddEntryRequest struct {
	Log   *LogRef   `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
	Value *LeafData `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *LogAddEntryRequest) Reset()                    { *m = LogAddEntryRequest{} }
func (m *LogAddEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*LogAddEntryRequest) ProtoMessage()               {}
func (*LogAddEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{12} }

func (m *LogAddEntryRequest) GetLog() *LogRef {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogAddEntryRequest) GetValue() *LeafData {
	if m != nil {
		return m.Value
	}
	return nil
}

type LogAddEntryResponse struct {
	LeafHash []byte `protobuf:"bytes,1,opt,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
}

func (m *LogAddEntryResponse) Reset()                    { *m = LogAddEntryResponse{} }
func (m *LogAddEntryResponse) String() string            { return proto.CompactTextString(m) }
func (*LogAddEntryResponse) ProtoMessage()               {}
func (*LogAddEntryResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{13} }

func (m *LogAddEntryResponse) GetLeafHash() []byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

type MapSetValueRequest struct {
	Map      *MapRef      `protobuf:"bytes,1,opt,name=map" json:"map,omitempty"`
	Mutation *MapMutation `protobuf:"bytes,2,opt,name=mutation" json:"mutation,omitempty"`
}

func (m *MapSetValueRequest) Reset()                    { *m = MapSetValueRequest{} }
func (m *MapSetValueRequest) String() string            { return proto.CompactTextString(m) }
func (*MapSetValueRequest) ProtoMessage()               {}
func (*MapSetValueRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{14} }

func (m *MapSetValueRequest) GetMap() *MapRef {
	if m != nil {
		return m.Map
	}
	return nil
}

func (m *MapSetValueRequest) GetMutation() *MapMutation {
	if m != nil {
		return m.Mutation
	}
	return nil
}

type MapSetValueResponse struct {
	LeafHash []byte `protobuf:"bytes,1,opt,name=leaf_hash,json=leafHash,proto3" json:"leaf_hash,omitempty"`
}

func (m *MapSetValueResponse) Reset()                    { *m = MapSetValueResponse{} }
func (m *MapSetValueResponse) String() string            { return proto.CompactTextString(m) }
func (*MapSetValueResponse) ProtoMessage()               {}
func (*MapSetValueResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{15} }

func (m *MapSetValueResponse) GetLeafHash() []byte {
	if m != nil {
		return m.LeafHash
	}
	return nil
}

type MapGetValueRequest struct {
	Map      *MapRef `protobuf:"bytes,1,opt,name=map" json:"map,omitempty"`
	TreeSize int64   `protobuf:"varint,2,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	Key      []byte  `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *MapGetValueRequest) Reset()                    { *m = MapGetValueRequest{} }
func (m *MapGetValueRequest) String() string            { return proto.CompactTextString(m) }
func (*MapGetValueRequest) ProtoMessage()               {}
func (*MapGetValueRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{16} }

func (m *MapGetValueRequest) GetMap() *MapRef {
	if m != nil {
		return m.Map
	}
	return nil
}

func (m *MapGetValueRequest) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *MapGetValueRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type MapGetValueResponse struct {
	TreeSize  int64     `protobuf:"varint,1,opt,name=tree_size,json=treeSize" json:"tree_size,omitempty"`
	AuditPath [][]byte  `protobuf:"bytes,2,rep,name=audit_path,json=auditPath,proto3" json:"audit_path,omitempty"`
	Value     *LeafData `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *MapGetValueResponse) Reset()                    { *m = MapGetValueResponse{} }
func (m *MapGetValueResponse) String() string            { return proto.CompactTextString(m) }
func (*MapGetValueResponse) ProtoMessage()               {}
func (*MapGetValueResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{17} }

func (m *MapGetValueResponse) GetTreeSize() int64 {
	if m != nil {
		return m.TreeSize
	}
	return 0
}

func (m *MapGetValueResponse) GetAuditPath() [][]byte {
	if m != nil {
		return m.AuditPath
	}
	return nil
}

func (m *MapGetValueResponse) GetValue() *LeafData {
	if m != nil {
		return m.Value
	}
	return nil
}

type LogFetchEntriesRequest struct {
	Log   *LogRef `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
	First int64   `protobuf:"varint,2,opt,name=first" json:"first,omitempty"`
	Last  int64   `protobuf:"varint,3,opt,name=last" json:"last,omitempty"`
}

func (m *LogFetchEntriesRequest) Reset()                    { *m = LogFetchEntriesRequest{} }
func (m *LogFetchEntriesRequest) String() string            { return proto.CompactTextString(m) }
func (*LogFetchEntriesRequest) ProtoMessage()               {}
func (*LogFetchEntriesRequest) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{18} }

func (m *LogFetchEntriesRequest) GetLog() *LogRef {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *LogFetchEntriesRequest) GetFirst() int64 {
	if m != nil {
		return m.First
	}
	return 0
}

func (m *LogFetchEntriesRequest) GetLast() int64 {
	if m != nil {
		return m.Last
	}
	return 0
}

type LogFetchEntriesResponse struct {
	Values []*LeafData `protobuf:"bytes,1,rep,name=values" json:"values,omitempty"`
}

func (m *LogFetchEntriesResponse) Reset()                    { *m = LogFetchEntriesResponse{} }
func (m *LogFetchEntriesResponse) String() string            { return proto.CompactTextString(m) }
func (*LogFetchEntriesResponse) ProtoMessage()               {}
func (*LogFetchEntriesResponse) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{19} }

func (m *LogFetchEntriesResponse) GetValues() []*LeafData {
	if m != nil {
		return m.Values
	}
	return nil
}

type MapMutation struct {
	Timestamp        string    `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Action           string    `protobuf:"bytes,2,opt,name=action" json:"action,omitempty"`
	Key              []byte    `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Value            *LeafData `protobuf:"bytes,4,opt,name=value" json:"value,omitempty"`
	PreviousLeafHash []byte    `protobuf:"bytes,5,opt,name=previous_leaf_hash,json=previousLeafHash,proto3" json:"previous_leaf_hash,omitempty"`
}

func (m *MapMutation) Reset()                    { *m = MapMutation{} }
func (m *MapMutation) String() string            { return proto.CompactTextString(m) }
func (*MapMutation) ProtoMessage()               {}
func (*MapMutation) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{20} }

func (m *MapMutation) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *MapMutation) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *MapMutation) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *MapMutation) GetValue() *LeafData {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *MapMutation) GetPreviousLeafHash() []byte {
	if m != nil {
		return m.PreviousLeafHash
	}
	return nil
}

func init() {
	proto.RegisterType((*AccountRef)(nil), "continusec.verifiabledatastructures.api.AccountRef")
	proto.RegisterType((*LogRef)(nil), "continusec.verifiabledatastructures.api.LogRef")
	proto.RegisterType((*MapRef)(nil), "continusec.verifiabledatastructures.api.MapRef")
	proto.RegisterType((*LogTreeHashRequest)(nil), "continusec.verifiabledatastructures.api.LogTreeHashRequest")
	proto.RegisterType((*LogTreeHashResponse)(nil), "continusec.verifiabledatastructures.api.LogTreeHashResponse")
	proto.RegisterType((*MapTreeHashRequest)(nil), "continusec.verifiabledatastructures.api.MapTreeHashRequest")
	proto.RegisterType((*MapTreeHashResponse)(nil), "continusec.verifiabledatastructures.api.MapTreeHashResponse")
	proto.RegisterType((*LogInclusionProofRequest)(nil), "continusec.verifiabledatastructures.api.LogInclusionProofRequest")
	proto.RegisterType((*LogInclusionProofResponse)(nil), "continusec.verifiabledatastructures.api.LogInclusionProofResponse")
	proto.RegisterType((*LogConsistencyProofRequest)(nil), "continusec.verifiabledatastructures.api.LogConsistencyProofRequest")
	proto.RegisterType((*LogConsistencyProofResponse)(nil), "continusec.verifiabledatastructures.api.LogConsistencyProofResponse")
	proto.RegisterType((*LeafData)(nil), "continusec.verifiabledatastructures.api.LeafData")
	proto.RegisterType((*LogAddEntryRequest)(nil), "continusec.verifiabledatastructures.api.LogAddEntryRequest")
	proto.RegisterType((*LogAddEntryResponse)(nil), "continusec.verifiabledatastructures.api.LogAddEntryResponse")
	proto.RegisterType((*MapSetValueRequest)(nil), "continusec.verifiabledatastructures.api.MapSetValueRequest")
	proto.RegisterType((*MapSetValueResponse)(nil), "continusec.verifiabledatastructures.api.MapSetValueResponse")
	proto.RegisterType((*MapGetValueRequest)(nil), "continusec.verifiabledatastructures.api.MapGetValueRequest")
	proto.RegisterType((*MapGetValueResponse)(nil), "continusec.verifiabledatastructures.api.MapGetValueResponse")
	proto.RegisterType((*LogFetchEntriesRequest)(nil), "continusec.verifiabledatastructures.api.LogFetchEntriesRequest")
	proto.RegisterType((*LogFetchEntriesResponse)(nil), "continusec.verifiabledatastructures.api.LogFetchEntriesResponse")
	proto.RegisterType((*MapMutation)(nil), "continusec.verifiabledatastructures.api.MapMutation")
	proto.RegisterEnum("continusec.verifiabledatastructures.api.LogType", LogType_name, LogType_value)
	proto.RegisterEnum("continusec.verifiabledatastructures.api.DataFormat", DataFormat_name, DataFormat_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for VerifiableDataStructuresService service

type VerifiableDataStructuresServiceClient interface {
	LogAddEntry(ctx context.Context, in *LogAddEntryRequest, opts ...grpc.CallOption) (*LogAddEntryResponse, error)
	LogFetchEntries(ctx context.Context, in *LogFetchEntriesRequest, opts ...grpc.CallOption) (*LogFetchEntriesResponse, error)
	LogTreeHash(ctx context.Context, in *LogTreeHashRequest, opts ...grpc.CallOption) (*LogTreeHashResponse, error)
	LogInclusionProof(ctx context.Context, in *LogInclusionProofRequest, opts ...grpc.CallOption) (*LogInclusionProofResponse, error)
	LogConsistencyProof(ctx context.Context, in *LogConsistencyProofRequest, opts ...grpc.CallOption) (*LogConsistencyProofResponse, error)
	MapSetValue(ctx context.Context, in *MapSetValueRequest, opts ...grpc.CallOption) (*MapSetValueResponse, error)
	MapGetValue(ctx context.Context, in *MapGetValueRequest, opts ...grpc.CallOption) (*MapGetValueResponse, error)
	MapTreeHash(ctx context.Context, in *MapTreeHashRequest, opts ...grpc.CallOption) (*MapTreeHashResponse, error)
}

type verifiableDataStructuresServiceClient struct {
	cc *grpc.ClientConn
}

func NewVerifiableDataStructuresServiceClient(cc *grpc.ClientConn) VerifiableDataStructuresServiceClient {
	return &verifiableDataStructuresServiceClient{cc}
}

func (c *verifiableDataStructuresServiceClient) LogAddEntry(ctx context.Context, in *LogAddEntryRequest, opts ...grpc.CallOption) (*LogAddEntryResponse, error) {
	out := new(LogAddEntryResponse)
	err := grpc.Invoke(ctx, "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogAddEntry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) LogFetchEntries(ctx context.Context, in *LogFetchEntriesRequest, opts ...grpc.CallOption) (*LogFetchEntriesResponse, error) {
	out := new(LogFetchEntriesResponse)
	err := grpc.Invoke(ctx, "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogFetchEntries", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) LogTreeHash(ctx context.Context, in *LogTreeHashRequest, opts ...grpc.CallOption) (*LogTreeHashResponse, error) {
	out := new(LogTreeHashResponse)
	err := grpc.Invoke(ctx, "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogTreeHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) LogInclusionProof(ctx context.Context, in *LogInclusionProofRequest, opts ...grpc.CallOption) (*LogInclusionProofResponse, error) {
	out := new(LogInclusionProofResponse)
	err := grpc.Invoke(ctx, "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogInclusionProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) LogConsistencyProof(ctx context.Context, in *LogConsistencyProofRequest, opts ...grpc.CallOption) (*LogConsistencyProofResponse, error) {
	out := new(LogConsistencyProofResponse)
	err := grpc.Invoke(ctx, "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogConsistencyProof", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) MapSetValue(ctx context.Context, in *MapSetValueRequest, opts ...grpc.CallOption) (*MapSetValueResponse, error) {
	out := new(MapSetValueResponse)
	err := grpc.Invoke(ctx, "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapSetValue", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) MapGetValue(ctx context.Context, in *MapGetValueRequest, opts ...grpc.CallOption) (*MapGetValueResponse, error) {
	out := new(MapGetValueResponse)
	err := grpc.Invoke(ctx, "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapGetValue", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *verifiableDataStructuresServiceClient) MapTreeHash(ctx context.Context, in *MapTreeHashRequest, opts ...grpc.CallOption) (*MapTreeHashResponse, error) {
	out := new(MapTreeHashResponse)
	err := grpc.Invoke(ctx, "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapTreeHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VerifiableDataStructuresService service

type VerifiableDataStructuresServiceServer interface {
	LogAddEntry(context.Context, *LogAddEntryRequest) (*LogAddEntryResponse, error)
	LogFetchEntries(context.Context, *LogFetchEntriesRequest) (*LogFetchEntriesResponse, error)
	LogTreeHash(context.Context, *LogTreeHashRequest) (*LogTreeHashResponse, error)
	LogInclusionProof(context.Context, *LogInclusionProofRequest) (*LogInclusionProofResponse, error)
	LogConsistencyProof(context.Context, *LogConsistencyProofRequest) (*LogConsistencyProofResponse, error)
	MapSetValue(context.Context, *MapSetValueRequest) (*MapSetValueResponse, error)
	MapGetValue(context.Context, *MapGetValueRequest) (*MapGetValueResponse, error)
	MapTreeHash(context.Context, *MapTreeHashRequest) (*MapTreeHashResponse, error)
}

func RegisterVerifiableDataStructuresServiceServer(s *grpc.Server, srv VerifiableDataStructuresServiceServer) {
	s.RegisterService(&_VerifiableDataStructuresService_serviceDesc, srv)
}

func _VerifiableDataStructuresService_LogAddEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogAddEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).LogAddEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogAddEntry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).LogAddEntry(ctx, req.(*LogAddEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_LogFetchEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogFetchEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).LogFetchEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogFetchEntries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).LogFetchEntries(ctx, req.(*LogFetchEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_LogTreeHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogTreeHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).LogTreeHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogTreeHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).LogTreeHash(ctx, req.(*LogTreeHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_LogInclusionProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogInclusionProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).LogInclusionProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogInclusionProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).LogInclusionProof(ctx, req.(*LogInclusionProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_LogConsistencyProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogConsistencyProofRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).LogConsistencyProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/LogConsistencyProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).LogConsistencyProof(ctx, req.(*LogConsistencyProofRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_MapSetValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapSetValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).MapSetValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapSetValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).MapSetValue(ctx, req.(*MapSetValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_MapGetValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapGetValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).MapGetValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapGetValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).MapGetValue(ctx, req.(*MapGetValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VerifiableDataStructuresService_MapTreeHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapTreeHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VerifiableDataStructuresServiceServer).MapTreeHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/continusec.verifiabledatastructures.api.VerifiableDataStructuresService/MapTreeHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VerifiableDataStructuresServiceServer).MapTreeHash(ctx, req.(*MapTreeHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VerifiableDataStructuresService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "continusec.verifiabledatastructures.api.VerifiableDataStructuresService",
	HandlerType: (*VerifiableDataStructuresServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LogAddEntry",
			Handler:    _VerifiableDataStructuresService_LogAddEntry_Handler,
		},
		{
			MethodName: "LogFetchEntries",
			Handler:    _VerifiableDataStructuresService_LogFetchEntries_Handler,
		},
		{
			MethodName: "LogTreeHash",
			Handler:    _VerifiableDataStructuresService_LogTreeHash_Handler,
		},
		{
			MethodName: "LogInclusionProof",
			Handler:    _VerifiableDataStructuresService_LogInclusionProof_Handler,
		},
		{
			MethodName: "LogConsistencyProof",
			Handler:    _VerifiableDataStructuresService_LogConsistencyProof_Handler,
		},
		{
			MethodName: "MapSetValue",
			Handler:    _VerifiableDataStructuresService_MapSetValue_Handler,
		},
		{
			MethodName: "MapGetValue",
			Handler:    _VerifiableDataStructuresService_MapGetValue_Handler,
		},
		{
			MethodName: "MapTreeHash",
			Handler:    _VerifiableDataStructuresService_MapTreeHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 1062 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x58, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xce, 0xd8, 0xae, 0x7f, 0x3c, 0x47, 0x89, 0x99, 0xa0, 0xd6, 0x75, 0x8b, 0xa8, 0xf6, 0xd2,
	0xaa, 0x42, 0x06, 0x52, 0x38, 0x51, 0x09, 0xdc, 0xc4, 0x71, 0x4d, 0xec, 0xc4, 0x5a, 0x3b, 0x95,
	0xe8, 0x65, 0x35, 0x59, 0x8f, 0xed, 0x51, 0xd7, 0x3b, 0xcb, 0xee, 0xac, 0x55, 0xf7, 0x0e, 0x07,
	0xae, 0x08, 0x24, 0x10, 0x07, 0xc4, 0x8d, 0x3b, 0x07, 0x6e, 0xfc, 0x03, 0xfc, 0x51, 0x68, 0x66,
	0xd7, 0x5e, 0xff, 0xaa, 0xe5, 0xb5, 0x53, 0x6e, 0xeb, 0x37, 0x7a, 0xdf, 0xfb, 0xbe, 0x37, 0xdf,
	0xbe, 0x7d, 0x09, 0xe4, 0x88, 0xc3, 0xca, 0x8e, 0xcb, 0x05, 0xc7, 0x0f, 0x4d, 0x6e, 0x0b, 0x66,
	0xfb, 0x1e, 0x35, 0xcb, 0x23, 0xea, 0xb2, 0x1e, 0x23, 0xd7, 0x16, 0xed, 0x12, 0x41, 0x3c, 0xe1,
	0xfa, 0xa6, 0xf0, 0x5d, 0xea, 0x95, 0x89, 0xc3, 0xb4, 0xcf, 0x01, 0x2a, 0xa6, 0xc9, 0x7d, 0x5b,
	0xe8, 0xb4, 0x87, 0x0f, 0x20, 0xc1, 0xba, 0x45, 0xf4, 0x00, 0x3d, 0xca, 0xe9, 0x09, 0xd6, 0xc5,
	0x77, 0x20, 0x43, 0x1c, 0x66, 0xbc, 0xa2, 0xe3, 0x62, 0x42, 0x05, 0xd3, 0xc4, 0x61, 0xe7, 0x74,
	0xac, 0xfd, 0x8d, 0x20, 0xdd, 0xe0, 0x7d, 0x99, 0xd3, 0x84, 0x0c, 0x09, 0x10, 0x54, 0x62, 0xfe,
	0xf8, 0x49, 0x79, 0xc3, 0xe2, 0xe5, 0xa8, 0xb2, 0x3e, 0xc1, 0xc0, 0xe7, 0x90, 0xb5, 0x78, 0xdf,
	0x10, 0x63, 0x87, 0xaa, 0x9a, 0x07, 0xc7, 0x9f, 0x6c, 0x8c, 0xd7, 0xe0, 0xfd, 0xce, 0xd8, 0xa1,
	0x7a, 0xc6, 0x0a, 0x1e, 0x30, 0x86, 0x94, 0x4d, 0x86, 0xb4, 0x98, 0x54, 0xe4, 0xd5, 0xb3, 0xf6,
	0x0a, 0xd2, 0x4d, 0xe2, 0xbc, 0x03, 0xe6, 0xab, 0x8a, 0x09, 0xc0, 0x92, 0x94, 0x4b, 0xe9, 0x73,
	0xe2, 0x0d, 0x74, 0xfa, 0xad, 0x4f, 0x3d, 0x81, 0x2b, 0x90, 0xb4, 0x78, 0x3f, 0x2c, 0xfa, 0x71,
	0x1c, 0x79, 0xb2, 0xa0, 0xcc, 0xc5, 0xf7, 0x20, 0x27, 0x5c, 0x4a, 0x0d, 0x8f, 0xbd, 0x09, 0xfa,
	0x94, 0xd4, 0xb3, 0x32, 0xd0, 0x66, 0x6f, 0xa8, 0x76, 0x09, 0x47, 0x73, 0x55, 0x3d, 0x87, 0xdb,
	0x1e, 0x9d, 0xcf, 0x41, 0xf3, 0x39, 0xf2, 0xd0, 0xe5, 0x5c, 0x18, 0x03, 0xe2, 0x0d, 0x14, 0xe0,
	0xbe, 0x9e, 0x95, 0x01, 0x89, 0x20, 0x65, 0x34, 0x89, 0xb3, 0x42, 0xc6, 0x90, 0x38, 0xb1, 0x65,
	0x04, 0xdd, 0xd7, 0x65, 0xee, 0x7a, 0x19, 0x3f, 0x22, 0x38, 0x9a, 0x2b, 0x1b, 0xe9, 0x88, 0xa8,
	0xa2, 0x79, 0xaa, 0xd8, 0x80, 0xfd, 0xa1, 0x2f, 0x88, 0x60, 0xdc, 0x36, 0x64, 0x93, 0x13, 0x8a,
	0xdd, 0xd3, 0x58, 0x1e, 0x5a, 0x28, 0xa8, 0xe7, 0x27, 0x88, 0x0d, 0xde, 0xd7, 0xfe, 0x42, 0x50,
	0x6c, 0xf0, 0x7e, 0xdd, 0x36, 0x2d, 0xdf, 0x63, 0xdc, 0x6e, 0xb9, 0x9c, 0xf7, 0xfe, 0xa7, 0x9b,
	0xc5, 0x77, 0x21, 0x3b, 0x14, 0x56, 0xa0, 0x3c, 0xa9, 0x94, 0x67, 0x86, 0xc2, 0x52, 0xc2, 0x3f,
	0x00, 0xb0, 0x28, 0xe9, 0x19, 0xcc, 0xee, 0xd2, 0xd7, 0xc5, 0x94, 0x4a, 0xcc, 0xc9, 0x48, 0x5d,
	0x06, 0xb4, 0x11, 0xdc, 0x5d, 0xc1, 0x7a, 0x13, 0x67, 0xcc, 0x03, 0x27, 0x16, 0x80, 0xe5, 0x31,
	0xf1, 0xbb, 0x4c, 0x18, 0x0e, 0x11, 0x92, 0x54, 0xf2, 0xd1, 0xbe, 0x9e, 0x53, 0x91, 0x16, 0x11,
	0x03, 0xed, 0x17, 0x04, 0xa5, 0x06, 0xef, 0x9f, 0x70, 0xdb, 0x63, 0x9e, 0xa0, 0xb6, 0x39, 0x7e,
	0x07, 0x0d, 0xeb, 0xb9, 0x7c, 0x38, 0xd7, 0x30, 0x19, 0x98, 0xd8, 0x3a, 0x52, 0x96, 0x5c, 0x30,
	0xd8, 0x08, 0xee, 0xad, 0xa4, 0x16, 0x75, 0x25, 0x02, 0x46, 0xeb, 0x80, 0x13, 0xcb, 0x2d, 0x5b,
	0xd7, 0x93, 0x9f, 0x10, 0x64, 0x1b, 0x94, 0xf4, 0x4e, 0x89, 0x20, 0x33, 0xed, 0x75, 0x7c, 0x11,
	0xda, 0x39, 0x6c, 0xaf, 0xe3, 0x0b, 0x79, 0x4c, 0x5f, 0x0b, 0x97, 0x18, 0xb2, 0x0b, 0xe1, 0x8b,
	0x99, 0x53, 0x11, 0x95, 0x7d, 0x0e, 0xe9, 0x1e, 0x77, 0x87, 0x44, 0x28, 0x71, 0x07, 0x31, 0x46,
	0x98, 0x4c, 0x3f, 0x53, 0xa9, 0x7a, 0x08, 0xa1, 0xfd, 0x8e, 0xd4, 0xb8, 0xaa, 0x74, 0xbb, 0x55,
	0x5b, 0xb8, 0xe3, 0x1b, 0xbc, 0xa3, 0x1a, 0xdc, 0x1a, 0x11, 0xcb, 0xa7, 0xe1, 0xeb, 0xf8, 0xe9,
	0xe6, 0x20, 0x61, 0x9b, 0xf4, 0x20, 0x5f, 0x3b, 0x56, 0xa3, 0x2d, 0x62, 0x18, 0x5d, 0x95, 0x6a,
	0xe2, 0xec, 0x48, 0x90, 0x01, 0x35, 0xbd, 0xfe, 0x44, 0x6a, 0x7c, 0xb5, 0xa9, 0x78, 0x21, 0x31,
	0x6e, 0x70, 0x7c, 0xb5, 0x20, 0x3b, 0x19, 0x0d, 0xa1, 0xb2, 0xcf, 0xe2, 0xe0, 0x34, 0xc3, 0x5c,
	0x7d, 0x8a, 0x22, 0xf5, 0xcd, 0x51, 0xdd, 0x44, 0xdf, 0xf7, 0x81, 0xbe, 0xda, 0xcd, 0xeb, 0x5b,
	0x6b, 0xf2, 0x02, 0x24, 0xe5, 0x62, 0x10, 0x8c, 0x21, 0xf9, 0xa8, 0xfd, 0x1a, 0x0c, 0xec, 0xda,
	0x0a, 0xf6, 0x6b, 0xc7, 0xcb, 0xcc, 0xbb, 0x92, 0x58, 0x78, 0x57, 0x22, 0xe7, 0x24, 0x77, 0x74,
	0xce, 0x77, 0x08, 0x6e, 0x37, 0x78, 0xff, 0x8c, 0x0a, 0x73, 0x20, 0xcd, 0xc3, 0xa8, 0x77, 0x83,
	0x06, 0x7f, 0x1f, 0x6e, 0xf5, 0x98, 0xeb, 0x89, 0xb0, 0x4b, 0xc1, 0x0f, 0xb9, 0x12, 0x58, 0xc4,
	0x13, 0xe1, 0xe0, 0x51, 0xcf, 0x5a, 0x17, 0xee, 0x2c, 0xd1, 0x08, 0xfb, 0x54, 0x87, 0xb4, 0xe2,
	0xea, 0x15, 0xd1, 0x83, 0xe4, 0x76, 0x62, 0x43, 0x00, 0xed, 0x5f, 0x04, 0xf9, 0x19, 0x87, 0xe1,
	0xfb, 0x90, 0x13, 0x6c, 0x48, 0x3d, 0x41, 0x86, 0x4e, 0xb8, 0xe0, 0x45, 0x01, 0x7c, 0x1b, 0xd2,
	0xc4, 0x9c, 0xba, 0x58, 0xae, 0x79, 0xea, 0xd7, 0xf2, 0x15, 0x47, 0xd7, 0x91, 0xda, 0xed, 0x3a,
	0xf0, 0x47, 0x80, 0x1d, 0x97, 0x8e, 0x18, 0xf7, 0x3d, 0x23, 0xb2, 0xf6, 0x2d, 0x55, 0xa9, 0x30,
	0x39, 0x69, 0x84, 0x16, 0x7f, 0xfc, 0x12, 0x32, 0xe1, 0x72, 0x87, 0x8f, 0xe0, 0xb0, 0xdd, 0xd1,
	0xaf, 0x4e, 0x3a, 0x46, 0xe7, 0x9b, 0x56, 0xd5, 0x68, 0x5c, 0xd6, 0x0a, 0x7b, 0xf8, 0x3e, 0x14,
	0x67, 0x83, 0xcd, 0xab, 0x4e, 0xa5, 0x53, 0xbf, 0xbc, 0x50, 0xa7, 0x68, 0xf1, 0xb4, 0xa3, 0x57,
	0xab, 0xcf, 0xab, 0x95, 0x53, 0x75, 0x9a, 0x78, 0xfc, 0x10, 0x20, 0x9a, 0x85, 0xf8, 0x10, 0xf2,
	0x57, 0x17, 0xed, 0x56, 0xf5, 0xa4, 0x7e, 0x56, 0xaf, 0x9e, 0x16, 0xf6, 0x70, 0x16, 0x52, 0x5f,
	0xb7, 0x2f, 0x2f, 0x0a, 0xe8, 0xf8, 0x9f, 0x1c, 0x7c, 0xf8, 0x62, 0xaa, 0x51, 0xe6, 0xb4, 0xa7,
	0x1a, 0xdb, 0xd4, 0x1d, 0x31, 0x93, 0xe2, 0x1f, 0x10, 0xe4, 0x67, 0x06, 0x14, 0xfe, 0x22, 0x8e,
	0x9b, 0x16, 0x06, 0x6f, 0xe9, 0xe9, 0x76, 0xc9, 0x81, 0x9b, 0xb4, 0x3d, 0xfc, 0x33, 0x82, 0xc3,
	0x05, 0xaf, 0xe1, 0x2f, 0xe3, 0x60, 0xae, 0x78, 0x59, 0x4a, 0x5f, 0x6d, 0x0f, 0x30, 0x25, 0x16,
	0x76, 0x69, 0xb2, 0x68, 0xc5, 0xeb, 0xd2, 0xc2, 0x1a, 0x5a, 0xda, 0x69, 0xb7, 0xd3, 0xf6, 0xf0,
	0x6f, 0x08, 0xde, 0x5b, 0x5a, 0x8d, 0x70, 0x25, 0x0e, 0xea, 0xca, 0x65, 0xb0, 0xf4, 0x6c, 0x17,
	0x88, 0x29, 0xbd, 0x3f, 0x90, 0xfa, 0xe4, 0x2d, 0x6e, 0x29, 0xf8, 0x24, 0x0e, 0xfa, 0x5b, 0xd6,
	0xaf, 0xd2, 0xe9, 0x6e, 0x20, 0x73, 0x17, 0x3a, 0xf3, 0xdd, 0x8a, 0x71, 0xa1, 0xcb, 0x1f, 0xe6,
	0x18, 0x17, 0xba, 0xe2, 0x53, 0x19, 0x91, 0xa9, 0x6d, 0x45, 0xa6, 0xb6, 0x0b, 0x99, 0xda, 0x5b,
	0xc9, 0x6c, 0x61, 0xf5, 0xe5, 0xbf, 0xb8, 0xe2, 0x91, 0x59, 0xb6, 0xfa, 0xb3, 0xd4, 0xcb, 0x84,
	0x73, 0x7d, 0x9d, 0x56, 0xff, 0x23, 0x78, 0xf2, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc5, 0xb2,
	0xf4, 0x5c, 0x30, 0x10, 0x00, 0x00,
}
